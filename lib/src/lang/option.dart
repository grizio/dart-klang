library klang.lang.option;

/// This function type is used by some methods for when the [Option] is non empty.
typedef dynamic WhenSome<A>(A a);

/// This function is used by some function for when the [Option] is empty.
typedef dynamic WhenNone();

/// This method is used by some functions for when the [Option] is empty.
typedef A DefaultValue<A>();

/// This method is used by some functions to check if the value verify a constraint.
typedef bool Verifying<A>(A elt);

/// This class represents optional values.
/// It encapsulates the value and provides some useful functions permitting to treat the value either it exists or not.
/// The conception is based on scala `Option`.
///
/// The developer can chain function calls to perform some operations.
///
///     Some(1).filter((a) => a > 0).map((a) => a + a).getOrElse(() => 0) // 2
///     Some(1).filter((a) => a > 2).map((a) => a + a).getOrElse(() => 0) // 0
class Option<A> {
  /// The encapsulated value.
  final A _value;

  /// Creates a new [Option] with given value which need to be encapsulated.
  Option([this._value=null]);

  /// Is the [Option] is non empty?
  bool get isDefined {
    return value != null;
  }

  /// Is the [Option] is empty?
  bool get isNotDefined {
    return !isDefined;
  }

  /// Calls different methods in terms of if the [Option] is empty or not.
  /// It simulates a pattern matching as we found in functional languages.
  ///
  /// If the [Option] is empty, this method will call [some],
  /// otherwise, it will call [none].
  ///
  ///     Some(1).match(some: (a) => a + a, none: () => 0) // 2
  ///     None.match(some: (a) => a + a, none: () => 0)    // 0
  dynamic match({WhenSome<A> some, WhenNone none}) {
    if (isDefined) {
      return some(value);
    } else {
      return none();
    }
  }

  /// Generates an new [Option] by calling then given [whenSome] or returns an empty [Option] if this one is already empty.
  ///
  ///     Some(1).map((a) => a + a) // Some(2)
  ///     None.map((a) => a + a)    // None
  Option<dynamic> map(WhenSome<A> whenSome) {
    if (isDefined) {
      return Some(whenSome(value));
    } else {
      return None;
    }
  }

  /// Call the given [whenSome] with encapsulated value if the [Option] is not empty.
  ///
  ///     Some(1).forEach(print) // prints "1"
  ///     None.forEach(print)    // Does nothing
  void forEach(WhenSome<A> whenSome) {
    if (isDefined) {
      whenSome(value);
    }
  }

  /// Returns the current value if this [Option] is not empty or null otherwise.
  ///
  ///     Some(1).get() // 1
  ///     None.get      // null
  A get() {
    return value;
  }

  /// Returns the current value if this [Option] is not empty or null otherwise.
  ///
  ///     Some(1).value // 1
  ///     None.value    // null
  A get value {
    return _value;
  }

  /// Returns the current value if the [Option] is not empty, otherwise the value generated by given [defaultValue].
  ///
  ///     Some(1).getOrElse(() => 2) // 1
  ///     None.getOrElse(() => 2)    // 2
  A getOrElse(DefaultValue<A> defaultValue) {
    return orElse(defaultValue).get();
  }

  /// Returns this [Option] if it is not null, otherwise another [Option] encapsulating the generated value obtained by [defaultValue].
  ///
  ///     Some(1).orElse(() => 2) // Some(1)
  ///     None.orElse(() => 2)    // Some(2)
  Option<A> orElse(DefaultValue<A> defaultValue) {
    if (isDefined) {
      return this;
    } else {
      return Some(defaultValue());
    }
  }

  /// Checks if this [Option] contains the given [elt].
  ///
  ///     Some(1).contains(1) // true
  ///     Some(1).contains(2) // false
  ///     None.contains(1)    // false
  bool contains(A elt) {
    return isDefined && elt == _value;
  }

  /// Counts the number of elements for which [verifying] returns [true].
  ///
  ///     Some(1).count((a) => a > 0) // 1
  ///     Some(1).count((a) => a > 2) // 0
  ///     None.count((a) => a > 0)    // 0
  int count(Verifying verifying) {
    if (exists(verifying)) {
      return 1;
    } else {
      return 0;
    }
  }

  /// Checks if this [Option] contains at least one element for which [verifying] returns [true].
  ///
  ///     Some(1).exists((_) => _ > 0) // true
  ///     Some(1).exists((_) => _ > 2) // false
  ///     None.exists((_) => _ > 0)    // false
  bool exists(Verifying verifying) {
   return isDefined && verifying(value);
  }

  /// Filters this [Option] and generates another one with only elements for which [verifying] returns [true].
  ///
  ///     Some(1).filter((a) => a > 0) // Some(1)
  ///     Some(1).filter((a) => a > 2) // None
  ///     None.filter((a) => a > 0)    // None
  Option<A> filter(Verifying verifying) {
    if (exists(verifying)) {
      return this;
    } else {
      return None;
    }
  }

  /// Filters this [Option] and generates another one with only elements for which [verifying] returns [false].
  ///
  ///     Some(1).filterNot((a) => a > 0) // None
  ///     Some(1).filterNot((a) => a > 2) // Some(1)
  ///     None.filterNot((a) => a > 0)    // None
  Option<A> filterNot(Verifying verifying) {
    if (!exists(verifying)) {
      return this;
    } else {
      return None;
    }
  }

  /// Returns an [Option] for which [verifying] returns [false] with the encapsulated value.
  ///
  ///     Some(1).find((a) => a > 0) // Some(1)
  ///     Some(1).find((a) => a > 2) // None
  ///     None.find((a) => a > 0)    // None
  Option<A> find(Verifying verifying) {
    return filter(verifying);
  }

  @override
  String toString() {
    if (isDefined) {
      return value.toString();
    } else {
      return 'None';
    }
  }

  /// Returns the number of elements in this option.
  ///
  ///     Some(1).length // 1
  ///     None.length    // 0
  int get length {
    return isDefined ? 1 : 0;
  }

  /// Checks the equality of two elements.
  /// If the given element is not an [Option], returns aways false.
  ///
  ///     Some(1) == Some(1) // true
  ///     None    == None    // true
  ///     Some(1) == Some(2) // false
  ///     Some(1) == 1       // false
  ///     Some(1) == None    // false
  bool operator ==(o) {
    if (o is Option) {
      var opt = o as Option;
      if (isNotDefined && opt.isNotDefined) {
        return true;
      } else if (isNotDefined || opt.isNotDefined) {
        return false;
      } else {
        return value == opt.value;
      }
    } else {
      return false;
    }
  }
}

/// Represents an empty [Option]
var None = new Option();

/// Represents an [Option] encapsulating the given [value].
/// If the [value] is [null], returns [None]
Option<dynamic> Some(dynamic value) {
  if (value != null) {
    return new Option(value);
  } else {
    return None;
  }
}